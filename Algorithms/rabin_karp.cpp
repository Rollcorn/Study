#include <iostream>
#include <string>

/*
Rabin-Karp - это алгоритм rolling hash-идея состоит в том, чтобы иметь возможность перемещать подстроку на одну позицию в любом направлении (влево или вправо) и иметь возможность пересчитать hash с постоянным числом операций.

Дана строка S и текст T, состоящие из маленьких латинских букв. Требуется найти все вхождения строки S в текст T за время O (|S| + |T|).

Алгоритм. Посчитаем хэш для строки S. Посчитаем значения хэшей для всех префиксов строки T. Теперь переберём все подстроки T длины |S| и каждую сравним с |S| за время O (1).

Сравнивать подстроки придется только один раз, когда хэши совпали, сделат это придется для увеличения надежности и защиты от случая коллизии хэша.
*/

using namespace std;
//Здесь Р - это какое-то простое число, чем больше это Р тем меньше вероятность возникновения коллизии. (Вероятность коллизии тогда равна n(степень полинома - количество эллементов в подстроке) разделить на наше Р.
const P = 257;

uint32_t hash(string s){
    uint32_t sum = 0;
//factor - случайное число которое мы будем возводить в степень?
    uint32_t factor = 101;

    for(int i = s.length() - 1; i >= 0; i--){
        sum += s[i]*factor;
        factor *= P;    
    }

}

int main(){
    string s;
    getline(cin, s);

    string pattern;
    getline(cin, pattern);
    uint32_t pattern_hash = hash(pattern);

    uint32_t M = pattern.length();
    
    uint32_t pattern

    return 0;
}
